<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Luxury Tree - Custom Edition</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Ma+Shan+Zheng&display=swap');

    :root{
      --bg:#020205;
      --gold:#d4af37;
      --cream:#fffdf0;
    }

    body{
      margin:0; overflow:hidden; background-color:var(--bg);
      font-family:'Cinzel', serif;
      touch-action:none;
      user-select:none; -webkit-user-select:none;
    }
    #canvas-container{ width:100vw; height:100vh; position:absolute; z-index:1; }

    #ui-layer{
      position:absolute; width:100%; height:100%; z-index:10;
      pointer-events:none;
      background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.30) 100%);
    }

    #main-title{
      position:absolute;
      top:10%;
      left:50%;
      transform:translateX(-50%);
      width:100%;
      text-align:center;
      font-family:'Cinzel', serif;
      font-weight:800;
      font-size: clamp(36px, 7vw, 80px);
      letter-spacing:0.15em;
      text-transform: uppercase;
      pointer-events:none;
      z-index:20;
      opacity:0;
      min-height: 1.2em;

      background-clip:text;
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-image: linear-gradient(180deg, #fffdf0 0%, #eacda3 30%, #d6ae7b 60%, #8b6c42 100%);
      filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6));

      animation: titleFadeIn 2s ease-out forwards 1s;
      transition: filter 1.5s ease, background-image 1.5s ease;
    }

    @keyframes titleFadeIn{
      from{ opacity:0; transform: translate(-50%, -20px); }
      to{ opacity:1; transform: translate(-50%, 0); }
    }

    #loader{
      position:absolute; width:100%; height:100%;
      background:#000; z-index:100;
      display:flex; align-items:center; justify-content:center;
      transition: opacity 1.2s;
      pointer-events:none;
    }
    .spinner{
      width:40px; height:40px;
      border:2px solid rgba(212,175,55,0.10);
      border-top:2px solid var(--gold);
      border-radius:50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin{ 100%{ transform: rotate(360deg); } }

    #top-right-controls{
      position:absolute; top:20px; right:20px;
      z-index:30;
      display:flex; flex-direction:row; gap:15px;
      pointer-events:auto;
    }
    .control-col{ display:flex; flex-direction:column; gap:15px; }

    .control-btn{
      background: rgba(10,10,10,0.6);
      border:1px solid rgba(212,175,55,0.4);
      color: var(--gold);
      width:110px;
      padding:6px 0;
      border-radius:7px;
      font-family:'Cinzel', serif;
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      -webkit-tap-highlight-color: transparent;
    }
    .control-btn:hover{
      background: rgba(212,175,55,0.2);
      border-color: rgba(212,175,55,0.8);
      color:#fff;
      transform: scale(1.05);
    }
    .control-btn:active{ transform: scale(0.95); }
    .control-btn.disabled{ color:#666; border-color:#444; }

    #file-input{ display:none; }

    /* webcam preview (hidden by default) */
    #webcam-wrapper{
      position:absolute; bottom:20px; right:20px;
      opacity:0;
      pointer-events:none;
      border:1px solid rgba(212,175,55,0.5);
      border-radius:4px;
      background:#000;
      z-index:50;
      display:flex;
      transition: opacity 0.5s;
    }
    #webcam{ display:none; }
    #webcam-preview{ width:100%; height:100%; transform: scaleX(-1); }

    /* small hint (optional) */
    #hint{
      position:absolute;
      left:20px; bottom:20px;
      z-index:30;
      pointer-events:none;
      color: rgba(255,253,240,0.75);
      font-size:12px;
      letter-spacing:0.08em;
      text-shadow: 0 0 12px rgba(212,175,55,0.12);
      max-width: 48ch;
      line-height: 1.45;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader"><div class="spinner"></div></div>
  <div id="canvas-container"></div>

  <div id="ui-layer">
    <div id="main-title">Merry Christmas</div>

    <div id="top-right-controls">
      <div class="control-col" id="col-media">
        <button id="btn-bgm" class="control-btn">Èü≥‰πêÔºöOFF</button>
        <button id="btn-add-photo" class="control-btn">‰∏ä‰º†ÁÖßÁâá</button>
      </div>
      <div class="control-col" id="col-system">
        <button id="btn-fullscreen" class="control-btn">ÂÖ®Â±èÊòæÁ§∫</button>
        <button id="btn-switch-theme" class="control-btn">È¢úËâ≤ÂàáÊç¢</button>
        <button id="btn-toggle-cam" class="control-btn">ÊëÑÂÉèÂ§¥È¢ÑËßà</button>
      </div>
    </div>

    <input type="file" id="file-input" multiple accept="image/*" />
  </div>

  <div id="webcam-wrapper">
    <video id="webcam" autoplay playsinline webkit-playsinline muted></video>
    <canvas id="webcam-preview"></canvas>
  </div>

  <div id="hint">
    ÊâãÂäøÔºöÂº†ÂºÄÊâãÊéå=Êï£ÂºÄÔºõ‰º∏Âá∫È£üÊåá=ËÅöÁÑ¶ÂàáÊç¢ÁÖßÁâáÔºõÊääÊâãÂêàËµ∑Êù•ÔºàÈùûÂº†ÂºÄÔºâ=ÂõûÂà∞Âú£ËØûÊ†ëÔºõ<br>
    ‰∏ªÈ¢òÂàáÊç¢Ôºöüëç Êàñ ÂõõÊåáÂº†ÂºÄ+ÊãáÊåáÊî∂Êã¢Ôºà2ÁßíÈò≤ÊäñÔºâ„ÄÇ<br>
  </div>

  <!-- Local BGM -->
  <audio id="bgm" loop preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

    // =========================================================
    // CONFIG (keeps your "luxury" style)
    // =========================================================
    const CONFIG = {
      colors: {
        bg: 0x020205,
        gold: 0xffd700,
        red: 0x880000,
        green: 0x004400,
        iceBlue: 0xaaddff,
        iceCyan: 0x00ffff,
        iceMagenta: 0xff00cc,
        iceDeep: 0x002244,
        white: 0xffffff,
        barbieHot: 0xff1694,
        barbieSoft: 0xffb7c5,
        barbieViolet: 0xd461e3
      },
      particles: {
        count: 1800,
        dustCount: 1500,
        treeHeight: 28,
        treeRadius: 9,
        snowCount: 2500,
        snowSpeed: 10
      },
      camera: { z: 55 },
      gestures: {
        palmOpenThreshold: 0.35,
        sensitivity: 6.0
      }
    };

    // =========================================================
    // STATE (NO letter, NO import/export)
    // =========================================================
    const STATE = {
      mode: 'TREE',              // TREE | SCATTER | FOCUS
      focusTarget: null,
      currentPhotoIndex: -1,

      currentThemeIndex: 0,
      gestureDebounceTimer: 0,
      isGestureSwitchEnabled: true,

      scatterScale: 1.0,
      gestureBaseSpread: null,

      hand: { detected: false, x: 0, y: 0 },
      rotation: new THREE.Vector2(0, 0),
      spinVel: new THREE.Vector2(0, 0),
      time: 0,

      wasPointing: false,
      palmCenter: { x: 0.5, y: 0.5 },
      hasPalmCenter: false,

      starMesh: null,
      starHaloMesh: null
    };

    // =========================================================
    // Globals
    // =========================================================
    let scene, camera, renderer, composer, clock = new THREE.Clock();
    let mainGroup, starGroup, bgGroup, photoMeshGroup;
    let particleSystem = [];

    let galaxySystem = null;
    let snowSystem = null;
    let heartSystem = null;

    let handLandmarker = null, video = null, drawingUtils = null, canvasCtx = null;

    let caneTexture, snowTexture, heartTexture, matLib = {};

    const _tempVec = new THREE.Vector3();
    const _targetVec = new THREE.Vector3();
    const _invMatrix = new THREE.Matrix4();

    // =========================================================
    // DOM
    // =========================================================
    const loaderEl = document.getElementById('loader');
    const titleEl = document.getElementById('main-title');

    const btnBgm = document.getElementById('btn-bgm');
    const btnAddPhoto = document.getElementById('btn-add-photo');
    const btnFs = document.getElementById('btn-fullscreen');
    const btnSwitch = document.getElementById('btn-switch-theme');
    const btnToggleCam = document.getElementById('btn-toggle-cam');
    const fileInput = document.getElementById('file-input');

    const webcamWrapper = document.getElementById('webcam-wrapper');
    const bgmEl = document.getElementById('bgm');

    // =========================================================
    // BGM: local my_bgm (next to HTML)
    // =========================================================
    function setupBgmSources() {
      bgmEl.innerHTML = '';
      for (const src of ['my_bgm.mp3', 'my_bgm.m4a', 'my_bgm.ogg', 'my_bgm']) {
        const s = document.createElement('source');
        s.src = src;
        bgmEl.appendChild(s);
      }
      bgmEl.load();
    }
    setupBgmSources();

    let musicOn = false;
    btnBgm.addEventListener('click', async (e) => {
      e.stopPropagation();
      try {
        if (!musicOn) {
          await bgmEl.play();
          musicOn = true;
          btnBgm.textContent = 'Èü≥‰πêÔºöON';
        } else {
          bgmEl.pause();
          musicOn = false;
          btnBgm.textContent = 'Èü≥‰πêÔºöOFF';
        }
      } catch (err) {
        console.warn('Audio blocked:', err);
        alert('ÊµèËßàÂô®ÈòªÊ≠¢Ëá™Âä®Êí≠ÊîæÔºöËØ∑ÂÖàÁÇπ‰∏Ä‰∏ãÈ°µÈù¢Á©∫ÁôΩÂ§ÑÔºåÂÜçÁÇπ‚ÄúÈü≥‰πê‚Äù„ÄÇ\nÂπ∂Á°Æ‰øù my_bgm.mp3 ‰∏é HTML Âú®ÂêåÁõÆÂΩï„ÄÇ');
      }
    });

    // =========================================================
    // Init
    // =========================================================
    async function init() {
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createMaterials();

      createGalaxyBackground();
      createSnowBackground();
      createHeartBackground();

      createParticles();
      setupPostProcessing();
      setupEvents();

      switchTheme(0);

      initMediaPipe().catch((e) => {
        console.warn('MediaPipe init failed:', e);
        // Keep running without gestures
      });

      loaderEl.style.opacity = 0;
      setTimeout(() => loaderEl.remove(), 1200);

      animate();
    }

    // =========================================================
    // THREE
    // =========================================================
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 0, CONFIG.camera.z);

      renderer = new THREE.WebGLRenderer({
        antialias: false,
        powerPreference: 'high-performance',
        depth: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      document.getElementById('canvas-container').appendChild(renderer.domElement);

      bgGroup = new THREE.Group(); scene.add(bgGroup);
      mainGroup = new THREE.Group(); mainGroup.rotation.x = 0.1; scene.add(mainGroup);
      starGroup = new THREE.Group(); mainGroup.add(starGroup);
      photoMeshGroup = new THREE.Group(); mainGroup.add(photoMeshGroup);
    }

    function setupEnvironment() {
      const pmrem = new THREE.PMREMGenerator(renderer);
      pmrem.compileEquirectangularShader();
      scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
    }

    function setupLights() {
      scene.add(new THREE.AmbientLight(0xffffff, 0.2));

      const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40);
      bottomLight.position.set(0, -10, 10);
      mainGroup.add(bottomLight);

      const spotGold = new THREE.SpotLight(0xfff0dd, 800);
      spotGold.position.set(40, 60, 40);
      spotGold.angle = 0.4;
      spotGold.decay = 2;
      scene.add(spotGold);

      const spotBlue = new THREE.SpotLight(0x4455ff, 400);
      spotBlue.position.set(-40, 10, -30);
      spotBlue.lookAt(0, 0, 0);
      scene.add(spotBlue);
    }

    function setupPostProcessing() {
      const bloom = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
      );
      bloom.threshold = 0.75;
      bloom.strength = 0.5;
      bloom.radius = 0.5;

      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      composer.addPass(bloom);
    }

    // =========================================================
    // Textures / Materials
    // =========================================================
    function createFrostTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#666';
      ctx.fillRect(0, 0, 256, 256);

      for (let i = 0; i < 80; i++) {
        ctx.strokeStyle = `rgba(255,255,255,${0.2 + Math.random() * 0.5})`;
        ctx.lineWidth = Math.random() * 2 + 0.5;
        ctx.beginPath();
        const x = Math.random() * 256, y = Math.random() * 256;
        ctx.moveTo(x, y);
        ctx.lineTo(x + (Math.random() - 0.5) * 60, y + (Math.random() - 0.5) * 60);
        ctx.stroke();
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function createTextures() {
      // candy cane stripes
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 128, 128);
      ctx.fillStyle = '#aa0000';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0);
        ctx.lineTo(i + 32, 128);
        ctx.lineTo(i + 16, 128);
        ctx.lineTo(i - 16, 0);
      }
      ctx.fill();
      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.colorSpace = THREE.SRGBColorSpace;
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);

      // snow sprite
      const snowCvs = document.createElement('canvas');
      snowCvs.width = 32; snowCvs.height = 32;
      const sCtx = snowCvs.getContext('2d');
      const grad = sCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      sCtx.fillStyle = grad;
      sCtx.fillRect(0, 0, 32, 32);
      snowTexture = new THREE.CanvasTexture(snowCvs);
      snowTexture.colorSpace = THREE.SRGBColorSpace;

      // heart sprite
      const hCvs = document.createElement('canvas');
      hCvs.width = 64; hCvs.height = 64;
      const hCtx = hCvs.getContext('2d');
      hCtx.fillStyle = '#ffffff';
      hCtx.beginPath();
      hCtx.moveTo(32, 20);
      hCtx.bezierCurveTo(32, 17, 30, 10, 20, 10);
      hCtx.bezierCurveTo(10, 10, 10, 25, 10, 25);
      hCtx.bezierCurveTo(10, 35, 20, 42, 32, 55);
      hCtx.bezierCurveTo(44, 42, 54, 35, 54, 25);
      hCtx.bezierCurveTo(54, 25, 54, 10, 44, 10);
      hCtx.bezierCurveTo(36, 10, 32, 17, 32, 20);
      hCtx.fill();
      heartTexture = new THREE.CanvasTexture(hCvs);
      heartTexture.colorSpace = THREE.SRGBColorSpace;
    }

    function createMaterials() {
      matLib.gold = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.gold,
        metalness: 1.0,
        roughness: 0.15,
        envMapIntensity: 2.5,
        emissive: 0x664400,
        emissiveIntensity: 0.2
      });
      matLib.green = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.green,
        metalness: 0.4,
        roughness: 0.3,
        emissive: 0x001100,
        emissiveIntensity: 0.1
      });
      matLib.red = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.red,
        metalness: 0.6,
        roughness: 0.2,
        clearcoat: 1.0,
        emissive: 0x330000,
        emissiveIntensity: 0.4
      });
      matLib.candy = new THREE.MeshStandardMaterial({
        map: caneTexture,
        roughness: 0.3,
        metalness: 0.1,
        emissive: 0x222222
      });

      matLib.starGold = new THREE.MeshStandardMaterial({
        color: 0xffdd88,
        emissive: 0xffaa00,
        emissiveIntensity: 2.0,
        metalness: 1.0,
        roughness: 0
      });

      // Photo frames per theme
      matLib.frameGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });

      const frostTex = createFrostTexture();
      matLib.ice = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.95,
        thickness: 1.5,
        ior: 1.8,
        clearcoat: 1.0,
        envMapIntensity: 2.0,
        iridescence: 1.0,
        iridescenceIOR: 1.3,
        iridescenceThicknessRange: [100, 400],
        emissive: CONFIG.colors.iceBlue,
        emissiveIntensity: 0.3
      });
      matLib.frozenCyan = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceCyan,
        metalness: 0.8,
        roughness: 0.2,
        emissive: CONFIG.colors.iceCyan,
        emissiveIntensity: 2.0,
        clearcoat: 1.0
      });
      matLib.frozenMagenta = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceMagenta,
        metalness: 0.5,
        roughness: 0.2,
        emissive: CONFIG.colors.iceMagenta,
        emissiveIntensity: 1.5,
        clearcoat: 1.0
      });
      matLib.starIce = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.iceCyan,
        emissive: 0xffffff,
        emissiveIntensity: 3.0,
        metalness: 0.2,
        roughness: 0,
        transmission: 0.6,
        thickness: 3.0
      });
      matLib.snow = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.8,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.8
      });

      matLib.barbieMain = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.barbieHot,
        metalness: 0.2,
        roughness: 0.1,
        clearcoat: 1.0,
        emissive: 0x440022,
        emissiveIntensity: 0.3
      });
      matLib.barbieSoft = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.barbieSoft,
        metalness: 0.1,
        roughness: 0.4,
        emissive: 0x442233,
        emissiveIntensity: 0.2
      });
      matLib.pearl = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1,
        transmission: 0.1,
        clearcoat: 1.0,
        iridescence: 1.0,
        iridescenceIOR: 1.3
      });
      matLib.starBarbie = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.barbieHot,
        emissive: 0xff0088,
        emissiveIntensity: 4.0,
        metalness: 0.5,
        roughness: 0.1
      });
      matLib.frameBarbie = matLib.barbieMain;
      matLib.frameIce = matLib.ice;

      matLib.snowBorder = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        side: THREE.BackSide
      });

      matLib.dust = new THREE.MeshBasicMaterial({ color: 0xffffee, blending: THREE.AdditiveBlending });

      matLib.snowFlake = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.8,
        map: snowTexture,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      matLib.heartFlake = new THREE.PointsMaterial({
        color: CONFIG.colors.barbieHot,
        size: 1.5,
        map: heartTexture,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      // A little texture hint use
      frostTex.needsUpdate = true;
    }

    // =========================================================
    // Background Systems
    // =========================================================
    function createGalaxyBackground() {
      const geometry = new THREE.BufferGeometry(), count = 3000;
      const pos = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const colors = new Float32Array(count * 3);
      const c1 = new THREE.Color(0x88aaff), c2 = new THREE.Color(0xffffee), c3 = new THREE.Color(0xffd700);

      for (let i = 0; i < count; i++) {
        const r = 60 + Math.random() * 250;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        pos[i*3]   = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        pos[i*3+2] = r * Math.cos(phi);

        sizes[i] = Math.random() * 2.0;

        const t = Math.random();
        const finalC = (t < 0.6) ? c2 : (t < 0.9 ? c1 : c3);
        colors[i*3] = finalC.r; colors[i*3+1] = finalC.g; colors[i*3+2] = finalC.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      galaxySystem = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 1.0,
          transparent: true,
          opacity: 0.8,
          vertexColors: true,
          sizeAttenuation: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      bgGroup.add(galaxySystem);
    }

    function createSnowBackground() {
      const geometry = new THREE.BufferGeometry();
      const count = CONFIG.particles.snowCount;
      const pos = new Float32Array(count * 3);
      const velocities = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        pos[i*3] = (Math.random() - 0.5) * 100;
        pos[i*3+1] = (Math.random() - 0.5) * 100;
        pos[i*3+2] = (Math.random() - 0.5) * 60;
        velocities[i] = 1.0 + Math.random();
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

      snowSystem = new THREE.Points(geometry, matLib.snowFlake);
      snowSystem.visible = false;
      bgGroup.add(snowSystem);
    }

    function createHeartBackground() {
      const geometry = new THREE.BufferGeometry();
      const count = 1500;
      const pos = new Float32Array(count * 3);
      const velocities = new Float32Array(count);
      const colors = new Float32Array(count * 3);

      const c1 = new THREE.Color(CONFIG.colors.barbieHot);
      const c2 = new THREE.Color(CONFIG.colors.barbieSoft);
      const c3 = new THREE.Color(0xffffff);

      for (let i = 0; i < count; i++) {
        pos[i*3] = (Math.random() - 0.5) * 120;
        pos[i*3+1] = (Math.random() - 0.5) * 120;
        pos[i*3+2] = (Math.random() - 0.5) * 80;
        velocities[i] = 0.5 + Math.random() * 0.8;

        const t = Math.random();
        const finalC = (t < 0.4) ? c1 : (t < 0.7 ? c2 : c3);
        colors[i*3] = finalC.r; colors[i*3+1] = finalC.g; colors[i*3+2] = finalC.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const mat = matLib.heartFlake.clone();
      mat.vertexColors = true;

      heartSystem = new THREE.Points(geometry, mat);
      heartSystem.visible = false;
      bgGroup.add(heartSystem);
    }

    // =========================================================
    // Particles / Photos
    // =========================================================
    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();
        this.baseScale = mesh.scale.x;
        this.offset = Math.random() * 100;
        this.speed = 0.5 + Math.random();

        if (mesh.material && mesh.material.emissive) {
          this.baseEmissive = mesh.material.emissive.clone();
          this.hasEmissive = true;
        } else {
          this.hasEmissive = false;
        }

        this.calculatePositions();
      }

      calculatePositions() {
        const h = CONFIG.particles.treeHeight;
        let t = Math.random();

        if (Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
          const y = (t * h) - h / 2;
          const angle = t * Math.PI * 12;
          const rBase = CONFIG.particles.treeRadius * (1.0 - t);
          this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
        } else {
          t = Math.pow(t, 0.8);
          const y = (t * h) - h / 2;
          const angle = Math.random() * Math.PI * 2;
          const r = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t)) * Math.sqrt(Math.random());
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
        }

        const rScatter = this.isDust ? (15 + Math.random() * 25) : (10 + Math.random() * 15);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, time, mode, focusTargetMesh, invMatrix) {
        let target, s = this.baseScale, lerpSpeed = 3.0;

        if (mode === 'SCATTER') {
          _targetVec.copy(this.posScatter).multiplyScalar(STATE.scatterScale);
          target = _targetVec;
        } else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh && invMatrix) {
            _targetVec.set(0, 0, CONFIG.camera.z - 15).applyMatrix4(invMatrix);
            target = _targetVec;
            lerpSpeed = 6.0;
            this.mesh.lookAt(camera.position);
            s = this.baseScale * 5.0;
          } else {
            target = this.posScatter;
            s = 0.01;
          }
        } else {
          target = this.posTree;
        }

        _tempVec.copy(target);

        if (mode === 'TREE') {
          const floatScale = (STATE.currentThemeIndex === 1) ? 0.3 : 0.15;
          _tempVec.y += Math.sin(time * this.speed + this.offset) * floatScale;
          _tempVec.x += Math.cos(time * 0.5 * this.speed + this.offset) * 0.1;
        }
        this.mesh.position.lerp(_tempVec, lerpSpeed * dt);

        if (this.hasEmissive && mode === 'TREE' && !this.isDust) {
          const blink = Math.sin(time * 2 + this.offset);
          const maxEmit = (STATE.currentThemeIndex === 1) ? 3.0 : 2.5;
          this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * maxEmit) : 0.4;
        }

        if (mode !== 'FOCUS') {
          if (this.isDust) s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
          else if (mode === 'SCATTER' && this.type === 'PHOTO') s = this.baseScale * 2.5;

          if (STATE.currentThemeIndex === 1 && mode === 'TREE' && !this.isDust && this.type !== 'PHOTO') {
            s *= (1.0 + 0.2 * Math.sin(time * 3 + this.offset));
          }
        }

        this.mesh.scale.lerp(_tempVec.set(s, s, s), 5 * dt);
      }
    }

    function createParticles() {
      const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0),
        new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0),
        new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const candyGeo = new THREE.TubeGeometry(curve, 8, 0.08, 6, false);
      const dustGeo = new THREE.OctahedronGeometry(0.1, 0);

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh, type;

        if (rand < 0.35) { mesh = new THREE.Mesh(boxGeo, matLib.green); type = 'BOX'; }
        else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, matLib.gold); type = 'GOLD_BOX'; }
        else if (rand < 0.90) { mesh = new THREE.Mesh(sphereGeo, matLib.gold); type = 'GOLD_SPHERE'; }
        else if (rand < 0.96) { mesh = new THREE.Mesh(sphereGeo, matLib.red); type = 'RED'; }
        else { mesh = new THREE.Mesh(candyGeo, matLib.candy); type = 'CANE'; }

        const s = 0.4 + Math.random() * 0.4;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, type, false));
      }

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(dustGeo, matLib.dust);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }

      createStarTopper();
      // default: one built-in photo
      addDefaultPhoto();
    }

    function createStarTopper() {
      const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), matLib.starGold);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);

      const haloMat = new THREE.MeshBasicMaterial({
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.5,
        color: 0xffaa00
      });

      // avoid external sprite dependency: procedural halo
      const haloTex = makeRadialGlowTexture(256);
      haloMat.map = haloTex;

      const halo = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), haloMat);
      star.add(halo);

      starGroup.add(star);

      STATE.starMesh = star;
      STATE.starHaloMesh = halo;
    }

    function makeRadialGlowTexture(size = 256) {
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const ctx = c.getContext('2d');

      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      g.addColorStop(0, 'rgba(255, 200, 80, 1)');
      g.addColorStop(0.35, 'rgba(255, 200, 80, 0.45)');
      g.addColorStop(1, 'rgba(255, 200, 80, 0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    function makeDefaultPhotoTexture() {
      const c = document.createElement('canvas');
      c.width = 768; c.height = 512;
      const ctx = c.getContext('2d');

      ctx.fillStyle = '#0b0b0b';
      ctx.fillRect(0, 0, c.width, c.height);

      const rad = ctx.createRadialGradient(c.width*0.5, c.height*0.45, c.width*0.08, c.width*0.5, c.height*0.5, c.width*0.68);
      rad.addColorStop(0, 'rgba(255,255,255,0.16)');
      rad.addColorStop(0.6, 'rgba(212,175,55,0.10)');
      rad.addColorStop(1, 'rgba(0,0,0,0.85)');
      ctx.fillStyle = rad;
      ctx.fillRect(0, 0, c.width, c.height);

      ctx.font = '800 62px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const grad = ctx.createLinearGradient(0, c.height*0.35, c.width, c.height*0.65);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.6, '#fffdf0');
      grad.addColorStop(1, '#d4af37');
      ctx.fillStyle = grad;
      ctx.shadowColor = 'rgba(212,175,55,0.35)';
      ctx.shadowBlur = 18;
      ctx.fillText('JOYEUX', c.width * 0.5, c.height * 0.44);
      ctx.fillText('NOEL',   c.width * 0.5, c.height * 0.58);

      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(212,175,55,0.55)';
      ctx.lineWidth = 6;
      ctx.strokeRect(20, 20, c.width - 40, c.height - 40);

      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    function addDefaultPhoto() {
      const t = makeDefaultPhotoTexture();
      addPhotoToScene(t);
    }

    function addPhotoToScene(texture) {
      if (!texture || !texture.image) return;

      texture.colorSpace = THREE.SRGBColorSpace;

      const aspect = texture.image.width / texture.image.height;
      let photoW = (aspect >= 1) ? 1.2 : 1.2 * aspect;
      let photoH = (aspect >= 1) ? 1.2 / aspect : 1.2;

      const group = new THREE.Group();

      const frameGeo = new THREE.BoxGeometry(photoW + 0.15, photoH + 0.15, 0.1);
      let currentFrameMat;
      if (STATE.currentThemeIndex === 0) currentFrameMat = matLib.frameGold;
      else if (STATE.currentThemeIndex === 1) currentFrameMat = matLib.frameIce;
      else currentFrameMat = matLib.frameBarbie;

      const frame = new THREE.Mesh(frameGeo, currentFrameMat);
      group.add(frame);

      const photo = new THREE.Mesh(
        new THREE.PlaneGeometry(photoW, photoH),
        new THREE.MeshBasicMaterial({ map: texture })
      );
      photo.position.z = 0.06;
      group.add(photo);

      const borderGeo = new THREE.BoxGeometry(photoW + 0.25, photoH + 0.25, 0.08);
      const border = new THREE.Mesh(borderGeo, matLib.snowBorder);
      border.position.z = -0.02;
      border.visible = (STATE.currentThemeIndex !== 0);
      group.add(border);

      // add to scene
      photoMeshGroup.add(group);
      group.scale.setScalar(1.0);

      // NOTE: photo is a Particle too (type PHOTO)
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function handleImageUpload(e) {
      if (!e.target.files.length) return;

      Array.from(e.target.files).forEach((f) => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace; // important
            addPhotoToScene(t);
          });
        };
        reader.readAsDataURL(f);
      });

      fileInput.value = '';
    }

    // =========================================================
    // Theme switching (kept from your template)
    // =========================================================
    function switchTheme(themeIndex) {
      STATE.currentThemeIndex = themeIndex;

      if (titleEl) {
        if (themeIndex === 0) {
          titleEl.style.textShadow = '0 0 15px rgba(212, 175, 55, 0.4), 0 0 30px rgba(212, 175, 55, 0.2)';
        } else if (themeIndex === 1) {
          titleEl.style.textShadow = '0 0 15px rgba(0, 255, 255, 0.6), 0 0 30px rgba(0, 255, 255, 0.4), 0 0 45px rgba(170, 221, 255, 0.3)';
        } else if (themeIndex === 2) {
          titleEl.style.textShadow = '0 0 15px rgba(255, 22, 148, 0.6), 0 0 30px rgba(255, 183, 197, 0.4)';
        }
      }

      renderer.toneMappingExposure = (themeIndex === 1) ? 1.2 : (themeIndex === 2 ? 0.9 : 1.0);

      if (galaxySystem) galaxySystem.visible = (themeIndex === 0);
      if (snowSystem) snowSystem.visible = (themeIndex === 1);
      if (heartSystem) heartSystem.visible = (themeIndex === 2);

      const fogColor = (themeIndex === 2) ? 0x1a0510 : ((themeIndex === 1) ? 0x000510 : CONFIG.colors.bg);
      scene.fog.color.setHex(fogColor);
      scene.background.setHex(fogColor);

      // Update materials for particles + frames
      particleSystem.forEach((p) => {
        if (p.isDust) {
          if (themeIndex === 2) p.mesh.material.color?.setHex?.(CONFIG.colors.barbieSoft);
          else if (themeIndex === 1) p.mesh.material.color?.setHex?.(CONFIG.colors.iceCyan);
          else p.mesh.material.color?.setHex?.(0xffffee);
          return;
        }

        if (p.type === 'PHOTO') {
          const group = p.mesh;
          let frameMat;
          if (themeIndex === 0) frameMat = matLib.frameGold;
          else if (themeIndex === 1) frameMat = matLib.frameIce;
          else frameMat = matLib.frameBarbie;

          if (group.children[0]) group.children[0].material = frameMat;
          if (group.children[2]) group.children[2].visible = (themeIndex !== 0);
          return;
        }

        let newMat = null;
        if (themeIndex === 0) {
          if (p.type.includes('GOLD')) newMat = matLib.gold;
          else if (p.type === 'BOX') newMat = matLib.green;
          else if (p.type === 'RED') newMat = matLib.red;
          else if (p.type === 'CANE') newMat = matLib.candy;
        } else if (themeIndex === 1) {
          if (p.type === 'GOLD_SPHERE') newMat = matLib.frozenCyan;
          else if (p.type === 'GOLD_BOX' || p.type === 'BOX') newMat = matLib.ice;
          else if (p.type === 'RED') newMat = matLib.frozenMagenta;
          else if (p.type === 'CANE') newMat = matLib.snow;
        } else if (themeIndex === 2) {
          if (p.type.includes('GOLD')) newMat = matLib.barbieMain;
          else if (p.type === 'BOX') newMat = matLib.barbieSoft;
          else if (p.type === 'RED') newMat = matLib.pearl;
          else if (p.type === 'CANE') newMat = matLib.barbieMain;
        }

        if (newMat && p.mesh.material !== newMat) p.mesh.material = newMat;
      });

      if (STATE.starMesh && STATE.starHaloMesh) {
        if (themeIndex === 0) {
          STATE.starMesh.material = matLib.starGold;
          STATE.starHaloMesh.material.color.setHex(0xffaa00);
        } else if (themeIndex === 1) {
          STATE.starMesh.material = matLib.starIce;
          STATE.starHaloMesh.material.color.setHex(CONFIG.colors.iceCyan);
        } else {
          STATE.starMesh.material = matLib.starBarbie;
          STATE.starHaloMesh.material.color.setHex(CONFIG.colors.barbieHot);
        }
      }
    }

    // =========================================================
    // Events (NO import/export, NO letter)
    // =========================================================
    function setupEvents() {
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      btnAddPhoto.addEventListener('click', (e) => {
        e.stopPropagation();
        fileInput.click();
      });
      fileInput.addEventListener('change', handleImageUpload);

      btnFs.addEventListener('click', (e) => {
        e.stopPropagation();
        if (document.fullscreenElement) document.exitFullscreen();
        else document.documentElement.requestFullscreen().catch(console.warn);
      });

      btnSwitch.addEventListener('click', (e) => {
        e.stopPropagation();
        // click always switches; gesture switch can be toggled with this button
        switchTheme((STATE.currentThemeIndex + 1) % 3);
      });

      btnToggleCam.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = webcamWrapper.style.opacity === '1';
        webcamWrapper.style.opacity = isVisible ? '0' : '1';
      });

      // Optional: toggle "gesture theme switching" (double click the theme button)
      btnSwitch.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        STATE.isGestureSwitchEnabled = !STATE.isGestureSwitchEnabled;
        if (STATE.isGestureSwitchEnabled) btnSwitch.classList.remove('disabled');
        else btnSwitch.classList.add('disabled');
      });

      // iOS / browser audio: first user interaction can unlock audio
      window.addEventListener('pointerdown', () => {
        if (!musicOn && bgmEl.paused) {
          // don't auto-play, just prime decode
          bgmEl.load();
        }
      }, { once: true });
    }

    // =========================================================
    // MediaPipe (kept, gestures logic replaced per your request)
    // =========================================================
    async function initMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      video = document.getElementById('webcam');
      canvasCtx = document.getElementById('webcam-preview').getContext('2d');
      drawingUtils = new DrawingUtils(canvasCtx);

      if (navigator.mediaDevices?.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
        });
        video.srcObject = stream;

        video.addEventListener("loadeddata", () => {
          video.play().catch(console.warn);
          webcamWrapper.style.opacity = 0; // keep hidden by default

          const aspect = video.videoWidth / video.videoHeight;
          webcamWrapper.style.height = (120 / aspect) + 'px';

          const c = document.getElementById('webcam-preview');
          c.width = video.videoWidth;
          c.height = video.videoHeight;

          predictWebcam();
        });
      }
    }

    let lastVideoTime = -1;
    async function predictWebcam() {
      if (lastVideoTime !== video.currentTime && handLandmarker) {
        lastVideoTime = video.currentTime;

        const result = handLandmarker.detectForVideo(video, performance.now());

        canvasCtx.clearRect(0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);
        canvasCtx.drawImage(video, 0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);

        if (result.landmarks?.[0]) {
          drawingUtils.drawConnectors(result.landmarks[0], HandLandmarker.HAND_CONNECTIONS, { color: "#d4af37", lineWidth: 3 });
          drawingUtils.drawLandmarks(result.landmarks[0], { color: "#ffffff", lineWidth: 1, radius: 3 });

          processGestures(result.landmarks[0]);
        } else {
          STATE.hand.detected = false;
        }
      }
      requestAnimationFrame(predictWebcam);
    }

    // =========================================================
    // Gestures (EXACT behavior aligned to "ÂàöÊâçÂèë‰Ω†ÁöÑ‰ª£Á†Å")
    // - Open palm -> SCATTER
    // - Pointing -> FOCUS (cycle photos / star)
    // - Otherwise -> TREE
    // - Theme: (OldSwitchGesture) or (ThumbsUp) with 2s debounce
    // =========================================================
    function processGestures(lm) {
      STATE.hand.detected = true;

      const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);

      const dIndex  = dist(8, 0);
      const dMiddle = dist(12, 0);
      const dRing   = dist(16, 0);
      const dPinky  = dist(20, 0);

      const palmSize = dist(0, 9);

      // Theme switch gesture 1: 4 fingers open + thumb tucked
      const areFourFingersOpen =
        (dIndex > palmSize * 1.3) &&
        (dMiddle > palmSize * 1.3) &&
        (dRing > palmSize * 1.3) &&
        (dPinky > palmSize * 1.3);

      const isThumbTucked = dist(4, 9) < palmSize * 0.6;
      const isOldSwitchGesture = areFourFingersOpen && isThumbTucked;

      // Theme switch gesture 2: thumbs up
      const isThumbExtended = dist(4, 9) > palmSize * 0.85;
      const isIndexCurled   = dist(8, 9) < palmSize * 0.65;
      const isMiddleCurled  = dist(12, 9) < palmSize * 0.65;
      const isRingCurled    = dist(16, 9) < palmSize * 0.65;
      const isPinkyCurled   = dist(20, 9) < palmSize * 0.65;

      const isThumbsUpGesture =
        isThumbExtended && isIndexCurled && isMiddleCurled && isRingCurled && isPinkyCurled;

      if (isOldSwitchGesture || isThumbsUpGesture) {
        if (STATE.isGestureSwitchEnabled) {
          if (Date.now() - STATE.gestureDebounceTimer > 2000) {
            switchTheme((STATE.currentThemeIndex + 1) % 3);
            STATE.gestureDebounceTimer = Date.now();
          }
        }
      }

      // Pointing -> FOCUS
      const isPointing = dIndex > 0.1 && dMiddle < dIndex * 0.7 && dRing < dIndex * 0.7;

      // Open palm -> SCATTER
      const avgSpread = (dIndex + dMiddle + dRing + dPinky) / 4;
      const isPalmOpen = avgSpread > CONFIG.gestures.palmOpenThreshold;

      if (isPointing) {
        STATE.mode = 'FOCUS';
        if (!STATE.wasPointing) {
          const photos = particleSystem.filter(p => p.type === 'PHOTO');
          STATE.focusTarget = photos.length
            ? photos[(++STATE.currentPhotoIndex) % photos.length].mesh
            : STATE.starMesh;
        }
        STATE.wasPointing = true;
        STATE.hasPalmCenter = false;
        STATE.spinVel.x *= 0.9;
        STATE.spinVel.y *= 0.9;
      } else {
        STATE.wasPointing = false;

        if (isPalmOpen) {
          if (STATE.mode !== 'SCATTER' || !STATE.hasPalmCenter) {
            STATE.palmCenter = { x: lm[9].x, y: lm[9].y };
            STATE.hasPalmCenter = true;
            STATE.gestureBaseSpread = avgSpread;
            STATE.scatterScale = 1.0;
          }

          STATE.mode = 'SCATTER';

          if (STATE.gestureBaseSpread) {
            STATE.scatterScale += (THREE.MathUtils.clamp(Math.pow(STATE.gestureBaseSpread / avgSpread, 2), 0.1, 5.0) - STATE.scatterScale) * 0.15;
          }

          const gain = CONFIG.gestures.sensitivity;
          const dx = lm[9].x - STATE.palmCenter.x;
          const dy = lm[9].y - STATE.palmCenter.y;

          STATE.spinVel.x += (THREE.MathUtils.clamp(-dy * gain, -3, 3) - STATE.spinVel.x) * 0.2;
          STATE.spinVel.y += (THREE.MathUtils.clamp(dx * gain, -3, 3) - STATE.spinVel.y) * 0.2;

        } else {
          STATE.mode = 'TREE';
          STATE.hasPalmCenter = false;
          STATE.scatterScale = 1.0;
          STATE.spinVel.x *= 0.9;
          STATE.spinVel.y *= 0.9;
        }
      }

      // Hand position influence (not in focus)
      if (STATE.mode !== 'FOCUS') {
        STATE.hand.x += ((lm[9].x - 0.5) * 3.0 - STATE.hand.x) * 0.1;
        STATE.hand.y += ((lm[9].y - 0.5) * 3.0 - STATE.hand.y) * 0.1;
      }
    }

    // =========================================================
    // Animate
    // =========================================================
    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      STATE.time = clock.elapsedTime;

      const inputX = STATE.hand.detected ? STATE.hand.x : 0;

      if (STATE.mode === 'TREE') {
        const baseSpeed = (STATE.currentThemeIndex === 1) ? 0.6 : 0.4;
        STATE.rotation.y -= baseSpeed * dt;
        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0.15, dt * 2.0);
        mainGroup.rotation.z = THREE.MathUtils.lerp(mainGroup.rotation.z, inputX * 0.1, dt * 2);

      } else if (STATE.mode === 'SCATTER') {
        STATE.rotation.y += STATE.spinVel.y * dt;
        STATE.rotation.x += STATE.spinVel.x * dt;
        if (!STATE.hand.detected) {
          STATE.spinVel.x *= 0.95;
          STATE.spinVel.y *= 0.95;
        }

      } else if (STATE.mode === 'FOCUS') {
        _invMatrix.copy(mainGroup.matrixWorld).invert();
      }

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      // Background movement
      if (galaxySystem && galaxySystem.visible) {
        bgGroup.rotation.y -= 0.05 * dt;
      } else if ((snowSystem && snowSystem.visible) || (heartSystem && heartSystem.visible)) {
        const sys = snowSystem.visible ? snowSystem : heartSystem;
        const positions = sys.geometry.attributes.position.array;
        const velocities = sys.geometry.attributes.velocity.array;
        const count = snowSystem.visible ? CONFIG.particles.snowCount : 1500;

        for (let i = 0; i < count; i++) {
          positions[i*3+1] -= CONFIG.particles.snowSpeed * velocities[i] * dt;
          if (positions[i*3+1] < -50) positions[i*3+1] = 50;
        }
        sys.geometry.attributes.position.needsUpdate = true;
        bgGroup.rotation.y -= 0.02 * dt;
      }

      // Star animation
      if (STATE.starMesh) {
        STATE.starMesh.rotation.y -= dt;
        STATE.starMesh.rotation.z = Math.sin(STATE.time) * 0.2;
        STATE.starMesh.scale.setScalar(1.0 + Math.sin(STATE.time * 2) * 0.1);
      }

      // Update particles
      particleSystem.forEach(p => p.update(dt, STATE.time, STATE.mode, STATE.focusTarget, (STATE.mode === 'FOCUS' ? _invMatrix : null)));

      composer.render();
    }

    // =========================================================
    // Boot
    // =========================================================
    init();
  </script>
</body>
</html>

